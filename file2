clc; clear;

%% === Load Robot with Gripper ===
robot = importrobot('Tinkerkit_model/tinkerkit.urdf');
robot.DataFormat = 'row';
robot.Gravity = [0 0 -9.81];

% Add virtual end-effector frame 16cm beyond link4
eeOffset = 0.16;
eeBody = robotics.RigidBody('end_effector');
setFixedTransform(eeBody.Joint, trvec2tform([0 0 eeOffset]));
addBody(robot, eeBody, 'link4');

%% === Define Cartesian Waypoints (XYZ in meters) ===
home        = [0.20,  0.00, 0.20];
abovePick   = [0.15,  0.10, 0.15];
pickup      = [0.15,  0.10, 0.05];
aboveDrop   = [0.05, -0.15, 0.15];
drop        = [0.05, -0.15, 0.05];

waypoints = [home;
             abovePick;
             pickup;
             abovePick;
             aboveDrop;
             drop;
             aboveDrop;
             home];

%% === Generate Smooth Trajectory ===
traj = cscvn(waypoints');  % parametric spline
x = linspace(0, traj.breaks(end), 160);
eePos = ppval(traj, x)';   % [160 x 3] positions

%% === Inverse Kinematics Setup ===
ik = robotics.InverseKinematics('RigidBodyTree', robot);
ik.SolverAlgorithm = 'LevenbergMarquardt';
weights = [0 0 0 1 1 1];
initialguess = [pi/2, pi/2, pi/4, pi/4, 0, deg2rad(73)];  % Start open

configSoln = zeros(length(x), 6);

%% === Solve IK for Each Trajectory Point ===
for idx = 1:length(x)
    tform = trvec2tform(eePos(idx, :));  % row is already 1x3
    sol = ik('end_effector', tform, weights, initialguess);

    configSoln(idx, 1:4) = sol(1:4);
    configSoln(idx, 5) = 0;            % wrist vertical fixed
    configSoln(idx, 6) = deg2rad(73);  % gripper open default

    initialguess = configSoln(idx, :);
end

%% === Detect Pickup & Drop Indices in Trajectory ===
pickupIndex = dsearchn(eePos, pickup);
dropIndex   = dsearchn(eePos, drop);

% === Gripper Logic with Hold Windows ===
configSoln(:,6) = deg2rad(73);  % open

gripCloseStart = pickupIndex + 2;
gripCloseEnd   = dropIndex - 4;
configSoln(gripCloseStart:gripCloseEnd,6) = deg2rad(0);  % closed during move
configSoln(dropIndex:end, 6) = deg2rad(73);  % re-open after drop

%% === Setup Figure and Plot Environment ===
figure('Name','Pick and Place Animation');
ax = gca;
hold on

% Plot path and waypoints
fnplt(traj, 'r', 2);
plot3(waypoints(:,1), waypoints(:,2), waypoints(:,3), '.', ...
    'MarkerSize', 40, 'MarkerEdgeColor', 'k');

% Plot the cube object (pickup target)
objColor = [0.8 0.3 0.3];
cubeHandle = plot3(NaN, NaN, NaN, 's', ...
    'MarkerSize', 12, 'MarkerEdgeColor', 'k', ...
    'MarkerFaceColor', objColor);  % will be updated live

axis([-0.3 0.3 -0.3 0.3 -0.1 0.5]);
view(135, 20);
grid on
hold off

%% === Animate Robot and Object ===
objectAttached = true;

for idx = 1:length(x)
    show(robot, configSoln(idx,:), 'PreservePlot', false, 'Frames', 'off');
    title('Pick and Place Visualization');
    hold on

    % === Update Object Position ===
    if objectAttached
        eeTform = getTransform(robot, configSoln(idx,:), 'end_effector');
        eePosNow = tform2trvec(eeTform);
        if isvalid(cubeHandle)
            set(cubeHandle, 'XData', eePosNow(1), ...
                            'YData', eePosNow(2), ...
                            'ZData', eePosNow(3));
        end
        if idx >= dropIndex
            objectAttached = false;
        end
    else
        % Drop object at final location
        if isvalid(cubeHandle)
            set(cubeHandle, 'XData', drop(1), ...
                            'YData', drop(2), ...
                            'ZData', drop(3));
        end
    end

    if idx == pickupIndex || idx == dropIndex
        pause(0.3);
    end

    drawnow;
    pause(0.06);  % control playback speed here
end
