%% Import Robot and Add Virtual End Effector
clear
clc

robot = importrobot('Tinkerkit_model/tinkerkit4DOF.urdf');
robot2 = importrobot('Tinkerkit_model/tinkerkit.urdf');
numJoints = numel(homeConfiguration(robot));

eeOffset = 0.16;
eeBody = robotics.RigidBody('end_effector');
setFixedTransform(eeBody.Joint, trvec2tform([0 0 eeOffset]));
addBody(robot, eeBody, 'link4');

clc

%% Set HOME Position
config = homeConfiguration(robot);
config2 = homeConfiguration(robot2);

config(1).JointPosition = pi/2;
config(2).JointPosition = pi/2;
config(3).JointPosition = pi/4;
config(4).JointPosition = pi/4;

show(robot, config);
title('Arm: HOME Configuration')
axis([-0.3 0.3 -0.3 0.3 -0.1 0.5]);
hold on

%% Detect Points to Reach and Trajectory Tracking
% punto_iniziale=[0 0 0.4515]; %config=[pi/2 pi/2 pi/2 pi/2]
punto_iniziale = [0.2452 0 0.2562]; % Starting point
punto_palla = [0.1 0.2 0.05];       % Target: ball
punto_intermedio = [0.15 0 0.25];   % Intermediate waypoint
punto_scatola = [0.1 -0.2 0.05];    % Target: box

% Generate 4 random reachable points (workspace)
wayPoints = [punto_iniziale; ...
             (rand*0.15)+0.05 ((rand*4)-2)/10 (rand*0.35)+0.05; ...
             (rand*0.15)+0.05 ((rand*4)-2)/10 (rand*0.35)+0.05; ...
             (rand*0.15)+0.05 ((rand*4)-2)/10 (rand*0.35)+0.05; ...
             (rand*0.15)+0.05 ((rand*4)-2)/10 (rand*0.35)+0.05; ...
             punto_iniziale];

plot3(wayPoints(:,1),wayPoints(:,2),wayPoints(:,3),'.','MarkerSize',40,'MarkerEdgeColor','k'); 
hold on

traj = cscvn(wayPoints');
fnplt(traj,'r',2);
grid on
hold off

%% Inverse Kinematics on Trajectory
ik = robotics.InverseKinematics('RigidBodyTree',robot);
ik.SolverAlgorithm = 'LevenbergMarquardt';
weights = [0 0 0 1 1 1];
initialguess = config;
[n,~] = size(wayPoints);
totalPoints = n*20;

x = linspace(0, traj.breaks(end), totalPoints);
eePos = ppval(traj, x);

for idx = 1:size(eePos,2)
    tform = trvec2tform(eePos(:,idx)');
    configSoln(idx,:) = ik('end_effector', tform, weights, initialguess);
    initialguess = configSoln(idx,:);
end

%% Plot Trajectory Following
figure
title('Waypoints Tracking')
config2(5).JointPosition = 0;
config2(6).JointPosition = 73*pi/180;

for idx = 1:size(eePos,2)
    config2(1).JointPosition = configSoln(idx,1).JointPosition;
    config2(2).JointPosition = configSoln(idx,2).JointPosition;
    config2(3).JointPosition = configSoln(idx,3).JointPosition;
    config2(4).JointPosition = configSoln(idx,4).JointPosition;
    show(robot2,config2,'PreservePlot',false,'Frames','off');
    hold on
    if idx == 1
        fnplt(traj,'r',2);
        plot3(wayPoints(:,1),wayPoints(:,2),wayPoints(:,3),'.','MarkerSize',40,'MarkerEdgeColor','k');
    end
    pause(0.1)
end
hold off

%% Joint Command Matrix (Radians)
JointCommandsRad = zeros(size(eePos,2),numJoints);
wayPoints = wayPoints';

for i = 1:size(eePos,2)
    JointCommandsRad(i,1) = configSoln(i,1).JointPosition;
    JointCommandsRad(i,2) = configSoln(i,2).JointPosition;
    JointCommandsRad(i,3) = configSoln(i,3).JointPosition;
    JointCommandsRad(i,4) = configSoln(i,4).JointPosition;
end

JointCommandsRad = [JointCommandsRad(1,:); JointCommandsRad];
JointCommandsDeg = JointCommandsRad*180/pi;

%% Joint Command Signals
tot = 20;
step = tot/totalPoints;
time = 0:step:tot;

figure
base.time = time';
base.signals.values = JointCommandsDeg(:,1);
subplot(2,2,1);
plot(time,JointCommandsDeg(:,1)');
title('Base Motor Signal')
grid on

shoulder.time = time';
shoulder.signals.values = JointCommandsDeg(:,2);
subplot(2,2,2);
plot(time,JointCommandsDeg(:,2)');
title('Shoulder Motor Signal')
grid on

elbow.time = time';
elbow.signals.values = JointCommandsDeg(:,3);
subplot(2,2,3);
plot(time,JointCommandsDeg(:,3)');
title('Elbow Motor Signal')
grid on

wrist.time = time';
wrist.signals.values = JointCommandsDeg(:,4);
subplot(2,2,4);
plot(time,JointCommandsDeg(:,4)');
title('Wrist Motor Signal')
grid on
